---
date: "2016-12-01T16:00:00+02:00"
title: "Установка с source"
slug: "install-from-source"
weight: 10
toc: true
draft: false
menu:
  sidebar:
    parent: "installation"
    name: "Из source"
    weight: 30
    identifier: "install-from-source"
---

# Установка из source

Вам следует [установить go](https://golang.org/doc/install) и установить окружающую среду go
правильно. В частности, рекомендуется установить `$GOPATH`
переменную среды и добавить каталог или каталоги go bin
`${GOPATH//://bin:}/bin` в `$PATH`. См. Запись в вики Go для
[GOPATH](https://github.com/golang/go/wiki/GOPATH).

Далее [устанавливаем Node.js с npm](https://nodejs.org/en/download/) который
требуется для создания файлов JavaScript и CSS. Минимальная поддерживаемая версия Node.js
это {{< min-node-version >}} и рекомендуется последняя версия LTS.

**Примечание**: При выполнении задач make, требующих внешних инструментов, например
`make misspell-check`, Gitea автоматически загрузит и соберёт их как
нужно. Чтобы использовать их, вы должны иметь каталог `"$GOPATH/bin"`
по пути к исполняемому файлу. Если вы не добавите каталог go bin в
исполняемый файл, вам придётся управлять им самостоятельно.

**Примечание 2**: Go версии {{< min-go-version >}} или выше требуется. Однако рекомендуется
иметь ту же версию, что и наша непрерывная интеграция, см. совет, данный в
<a href='{{< relref "doc/advanced/hacking-on-gitea.ru-ru.md" >}}'>Hacking on Gitea</a>

## Скачивание

Во-первых, мы должны получить исходный код. С появлением модулей go
самый простой способ сделать это - использовать git напрямую, так как нам больше не нужно
gitea, созданная внутри GOPATH.

```bash
git clone https://github.com/go-gitea/gitea
```

(Предыдущие версии этого документа рекомендовали использовать `go get`. Это
больше не нужно.)

Решите, какую версию Gitea собрать и установить. В настоящее время есть
несколько вариантов на выбор. В branch'е `master` представляет текущую
версию в разработке. Чтобы построить с master'ом, перейдите к [разделу сборки](#сборка).

Для работы с помеченными релизами можно использовать следующие команды:

```bash
git branch -a
git checkout v{{< version >}}
```

Чтобы проверить Pull Request, сначала включите новую branch'а (`xyz` в PR id;
например `2663` для [#2663](https://github.com/go-gitea/gitea/pull/2663)):

```bash
git fetch origin pull/xyz/head:pr-xyz
```

Чтобы собрать Gitea из исходного кода в конкретном релизе с тегами (как v{{< version >}}), перечислите
доступные теги и проверьте конкретный тег.

Перечислить доступные теги следующим образом.

```bash
git tag -l
git checkout v{{< version >}}  # or git checkout pr-xyz
```

## Сборка

Для сборки из source в системе должны присутствовать следующие программы:

- `go` {{< min-go-version >}} или лучше, просмотрите [тут](https://golang.org/dl/)
- `node` {{< min-node-version >}} или лучше с `npm`, просмотрите [тут](https://nodejs.org/en/download/)
- `make`, просмотрите <a href='{{< relref "doc/advanced/make.ru-ru.md" >}}'>тут</a>

Различные [задачи](https://github.com/go-gitea/gitea/blob/master/Makefile)
предоставлены, чтобы максимально упростить процесс сборки.

В зависимости от требований могут быть включены следующие теги сборки.

* `bindata`: Создайте единый монолитный двоичный файл со всеми активами.
* `sqlite sqlite_unlock_notify`: Включить поддержку для базы данных
  [SQLite3](https://sqlite.org/). Предлагается только для крошечных
   установок.
* `pam`: Включить поддержку для PAM (Linux Pluggable Authentication Modules). Может
   использоваться для аутентификации локальных пользователей или расширения аутентификации для методов
   доступных для PAM.

Объединение активов в двоичный файл с помощью тега сборки `bindata` рекомендуется для
производственных развёртываний. Статические активы можно обслуживать напрямую через обратный прокси,
но в большинстве случаев в этом нет необходимости, и активы всё равно должны быть объединены в двоичный файл.
Вы можете исключить bindata при разработке/тестировании Gitea.
Чтобы включить активы, добавьте тег `bindata`:

```bash
TAGS="bindata" make build
```

В сборке релиза по умолчанию нашей системы непрерывной интеграции сборки
тега: `TAGS="bindata sqlite sqlite_unlock_notify"`. Простейший
поэтому рекомендуемый способ сборки из исходного кода:

```bash
TAGS="bindata sqlite sqlite_unlock_notify" make build
```

Цель `build` разделена на две подцели:

- `make backend` что требует [Go {{< min-go-version >}}](https://golang.org/dl/) или лучше.
- `make frontend` что требует [Node.js {{< min-node-version >}}](https://nodejs.org/en/download/) или лучше.

Если присутствуют предварительно созданные файлы внешнего интерфейса, можно создать только серверную часть:

```bash
TAGS="bindata" make backend
```

## Тест

После выполнения описанных выше шагов, двоичный файл `gitea` будет доступен в рабочем каталоге.
Его можно протестировать из этого каталога или переместить в каталог с тестовыми данными. Когда Gitea
запускается вручную из командной строки, его можно вырубить, нажав `Ctrl + C`.

```bash
./gitea web
```

## Изменение путей по умолчанию

Gitea будет искать ряд вещей в `CustomPath`. По умолчанию это
каталог `custom/` в текущем рабочем каталоге при запуске Gitea. Это также будет
искать его файл конфигурации `CustomConf` в `$CustomPath/conf/app.ini`, и будет использовать
текущий рабочий каталог как относительный базовый путь `AppWorkPath` для настраиваемого числа
чисел. Наконец, статические файлы будут обслуживаться из `StaticRootPath` который по умолчанию `AppWorkPath`.

Эти значения, хотя и полезны при разработке, могут конфликтовать с предпочтениями нижестоящих пользователей.

Один из вариантов - использовать файл сценария для теневого копирования двоичного файла `gitea` и создание соответствующего
окружения перед запуском Gitea. Однако при сборке вы можете изменить эти значения по умолчанию
используя переменную среду `LDFLAGS` для `make`. Соответствующие настройки следующие

* Чтобы установить `CustomPath` используйте `LDFLAGS="-X \"code.gitea.io/gitea/modules/setting.CustomPath=custom-path\""`
* Для `CustomConf` вы должны использовать `-X \"code.gitea.io/gitea/modules/setting.CustomConf=conf.ini\"`
* Для `AppWorkPath` вы должны использовать `-X \"code.gitea.io/gitea/modules/setting.AppWorkPath=working-path\"`
* Для `StaticRootPath` вы должны использовать`-X \"code.gitea.io/gitea/modules/setting.StaticRootPath=static-root-path\"`
* Чтобы изменить расположение файла PID по умолчанию, используйте `-X \"code.gitea.io/gitea/modules/setting.PIDFile=/run/gitea.pid\"`

Добавьте столько же строк с их предыдущими `-X` в переменную `LDFLAGS` и запустите `make build`
с соответствующими `TAGS` как указано выше.

Запуск `gitea help` позволит вам просмотреть, какими будут вычисленные настройки для вашего `gitea`.

## Перекрёстная сборка
Инструментальная цепочка компилятора `go` поддерживает кросс-компиляцию для различных целей архитектуры, которые поддерживаются этой инструментальной цепочкой. Просмотрите [переменные окружения `GOOS` и `GOARCH`](https://golang.org/doc/install/source#environment) для списка поддерживаемых целей. Кросс-компиляция полезна, если вы хотите собрать Gitea для менее мощных систем (таких как Raspberry Pi).

Перекрестная сборка Gitea с тегами сборки (`TAGS`), вам также понадобится кросс-компилятор C, ориентированный на ту же архитектуру, которая выбрана у переменных `GOOS` и `GOARCH`. Например, чтобы построить кросс для Linux ARM64 (`GOOS=linux` и `GOARCH=arm64`), вам нужен кросс-компилятор `aarch64-unknown-linux-gnu-gcc`. Это необходимо, поскольку теги сборки Gitea используют `cgo` foreign-function interface (FFI).

Кросс-сборка Gitea для Linux ARM64, без тегов:

```
GOOS=linux GOARCH=arm64 make build
```

Кросс-сборка Gitea для Linux ARM64 с рекомендованными тегами сборки:

```
CC=aarch64-unknown-linux-gnu-gcc GOOS=linux GOARCH=arm64 TAGS="bindata sqlite sqlite_unlock_notify" make build
```

Замените `CC`, `GOOS`, и `GOARCH` в зависимости от цели вашей архитектуры.
