---
date: "2019-04-02T17:06:00+01:00"
title: "Продвинутое: Конфигурация логгера"
slug: "logging-configuration"
weight: 55
toc: true
draft: false
menu:
  sidebar:
    parent: "advanced"
    name: "Конфигурация логгера"
    weight: 55
    identifier: "logging-configuration"
---

# Конфигурация логгера

В Gitea 1.9.0 была переработана структура ведения ооггера.

## Группы логгеров

Главное, что нужно знать в Gitea, - это то, что существует несколько
групп логгеров:

* Логгер "Default"
* Логгер Macaron
* Логгер Router
* Логгер Access
* Логгер XORM

Также есть логгер go журнала.

### Логгер go

Go предоставляет свой собственный чрезвычайно простой логгер
в пакете `log`, однако этого недостаточно для наших целей, поскольку
он не обеспечивает способ ведения логгера на нескольких уровнях и
не обеспечивает хороший способ контроля того, где эти журналы
регистрируются. кроме как через настройку писателя.

Поэтому мы перенаправили этот логгер в наш логгер по умолчанию, и мы
будем регистрировать всё, что зарегистрировано, используя логгер go на уровне INFO.

### Логгер "Default"

Вызывает `log.Info`,`log.Debug`, `log.Error` и т.д. из пакета `code.gitea.io/gitea/modules/log` войдёт в этот логгер.

Вы можете настроить выходы этого регистратора, установив значение `MODE`
в разделе `[log]` конфигурации.

Каждый выходной подлоггер настраивается в отдельном `[log.sublogger.default]`,
который наследуется от раздела подлоггера `[log.sublogger]` и от общего раздела
`[log]`, но есть определенные значения по умолчанию. Они не будут унаследованы от раздела `[log]`:

* `FLAGS` это `stdflags` (Равен
`date,time,medfile,shortfuncname,levelinitial`)
* `FILE_NAME` по умолчанию будет `%(ROOT_PATH)/gitea.log`
* `EXPRESSION` по умолчанию будет `""`
* `PREFIX` по умолчанию будет `""`

Тип провайдера сублоггера может быть установлен с помощью значения `MODE` в его
подразделе, но по умолчанию будет использоваться имя. Это позволяет вам иметь
несколько подлогеров, которые будут регистрироваться в файлах.

### Логгер "Macaron"

По умолчанию Macaron будет регистрироваться в собственном экземпляре go `log`.
Это пишет в `os.Stdout`. Вы можете перенаправить этот журнал в настраиваемый
регистратор Gitea, установив параметр `REDIRECT_MACARON_LOG` в разделе`[log]`,
для которого вы можете настроить выходы, установив значение`MACARON` в разделе
`[log]` конфигурации. `MACARON` по умолчанию имеет значение `file`, если не установлено.

Обратите внимание, что логгер Macaron будет регистрироваться на уровне `INFO`,
установка `LEVEL` этого логгера на `WARN` или выше не приведёт к созданию журналов macaron.

Каждый выходной подлоггер для этого регистратора настраивается
в разделах `[log.sublogger.macaron]`. Существуют определенные
значения по умолчанию, которые не будут унаследованы от разделов
`[log]` или соответствующих разделов `[log.sublogger]`:

* `FLAGS` это `stdflags` (Равен
`date,time,medfile,shortfuncname,levelinitial`)
* `FILE_NAME` по умолчанию будет `%(ROOT_PATH)/macaron.log`
* `EXPRESSION` по умолчанию будет `""`
* `PREFIX` по умолчанию будет `""`

NB: Вы можете перенаправить логгер macaron для отправки его событий
в журнал gitea, используя значение: `MACARON = ,`

### Логгер "Router"

Существует два типа журнала маршрутизатора. По умолчанию Macaron отправляет
свой собственный журнал маршрутизатора, который будет направлен в go `log` Macaron,
однако, если вы установите `REDIRECT_MACARON_LOG`, вы включите журнал маршрутизатора
Gitea. Вы можете отключить оба типа журнала маршрутизатора, установив `DISABLE_ROUTER_LOG`.

Если вы включили перенаправление, вы можете настроить выходы этого журнала
маршрутизатора, установив значение `ROUTER` в разделе`[log] `конфигурации.
Если не задано, `ROUTER` по умолчанию будет консолью. Маршрутизатор Gitea
регистрирует те же данные, что и журнал Macaron, но имеет немного другой цвет.
По умолчанию он регистрируется на уровне `Info`, но при желании его можно
изменить, установив значение`ROUTER_LOG_LEVEL`.

Обратите внимание: установка `LEVEL` этого логгера на уровень
выше `ROUTER_LOG_LEVEL` не приведёт к созданию журналов маршрутизатора.

Каждый выходной подлоггер для этого регистратора настраивается в
разделах `[log.sublogger.router]`. Существуют определённые значения
по умолчанию, которые не будут унаследованы от разделов `[log]` или
соответствующих разделов `[log.sublogger]`:

* `FILE_NAME` по умолчанию будет `%(ROOT_PATH)/router.log`
* `FLAGS` по умолчанию `date,time`
* `EXPRESSION` по умолчанию будет `""`
* `PREFIX` по умолчанию будет `""`

NB: Вы можете перенаправить логгер маршрутизатора для отправки его
событий в журнал Gitea, используя значение: `ROUTER = ,`

### Логгер "Access"

Логгер доступа - новый логгер для версии 1.9. Он обеспечивает
формат журнала, совместимый с NCSA Common Log. Он легко настраивается,
но при изменении его шаблона следует соблюдать осторожность. Основным
преимуществом этого логгера является то, что Gitea теперь может
регистрировать доступы в стандартном формате журнала, поэтому можно
использовать стандартные инструменты.

Вы можете включить этот логгер, используя `ENABLE_ACCESS_LOG`. Его
выходы конфигурируются путем установки значения ACCESS в разделе
конфигурации `[log]`. `ACCESS` по умолчанию - `file`, если не установлен.

Каждый выходной подлоггер для этого логгер настраивается в
разделах `[log.sublogger.access]`. Существуют определенные
значения по умолчанию, которые не будут унаследованы от
разделов `[log]` или соответствующих разделов `[log.sublogger]`:

* `FILE_NAME` по умолчанию будет `%(ROOT_PATH)/access.log`
* `FLAGS` по умолчанию `` or None
* `EXPRESSION` по умолчанию будет `""`
* `PREFIX` по умолчанию будет `""`

При желании формат логгера доступа можно изменить, изменив
значение `ACCESS_LOG_TEMPLATE`.

Учтите, что логгер доступа будет регистрироваться на уровне `INFO`,
установка `LEVEL` этого логгера на `WARN` или выше приведет к отсутствию
журналов доступа.

NB: Вы можете перенаправить логгер доступа для отправки его событий
в журнал Gitea, используя значение: `ACCESS = ,`

#### ACCESS_LOG_TEMPLATE

Это значение представляет собой шаблон перехода. Значение по умолчанию:

`{{.Ctx.RemoteAddr}} - {{.Identity}} {{.Start.Format "[02/Jan/2006:15:04:05 -0700]" }} "{{.Ctx.Req.Method}} {{.Ctx.Req.URL.RequestURI}} {{.Ctx.Req.Proto}}" {{.ResponseWriter.Status}} {{.ResponseWriter.Size}} "{{.Ctx.Req.Referer}}\" \"{{.Ctx.Req.UserAgent}}"`

В шаблон передаются следующие параметры:

* `Ctx` это `macaron.Context`
* `Identity` это `SignedUserName` или `"-"` если пользователь не
авторизован
* `Start` время начала запроса
* `ResponseWriter` это `macaron.ResponseWriter`

При изменении этого шаблона необходимо соблюдать осторожность, поскольку
он работает вне стандартной ловушки аварийного восстановления. Шаблон
также должен быть настолько простым, насколько он запускается для каждого запроса.

### Логгер "XORM"

Регистратор XORM - это давний регистратор, который существует для сбора событий
журнала XORM. Он включен по умолчанию, но может быть отключен, установив для
параметра `ENABLE_XORM_LOG` значение `false` в разделе `[log]`. Его выходы
настраиваются путем установки значения `XORM` в разделе` [log]` конфигурации.
По умолчанию `XORM` имеет значение `,` если не установлено, это означает, что
он перенаправляется в основной журнал Gitea.

XORM по умолчанию регистрирует события SQL. Это можно изменить, установив
значение `LOG_SQL` на `false` в разделе `[database]`.

Каждый выходной подлоггер для этого регистратора настраивается
в разделах `[log.sublogger.xorm]`. Существуют определенные значения
по умолчанию, которые не будут унаследованы от разделов `[log]` или
соответствующих разделов `[log.sublogger]`:

* `FILE_NAME` по умолчанию будет `%(ROOT_PATH)/xorm.log`
* `FLAGS` по умолчанию `date,time`
* `EXPRESSION` по умолчанию будет `""`
* `PREFIX` по умолчанию будет `""`

## Выходные данные журнала

Gitea предоставляет 4 возможных вывода журнала:

* `console` - Журналировать в `os.Stdout` или `os.Stderr`
* `file` - Журналировать в файл
* `conn` - Журналировать в поддерживающее TCP-соединение
* `smtp` - Журналировать по электронной почте

Определённая конфигурация является общей для всех режимов вывода журнала.:

* `LEVEL` это самый низкий уровень, который будет регистрироваться в
этом выводе. Это значение унаследовано от `[log]`, а в случае регистраторов
не по умолчанию - от `[log.sublogger]`.
* `STACKTRACE_LEVEL` это самый низкий уровень, на котором этот вывод
будет печатать трассировку. Это значение передаётся по наследству.
* `MODE` это режим вывода журнала. По умолчанию используется имя сублоггера.
Таким образом, `[log.console.macaron]` по умолчанию будет иметь значение `MODE = console`.
* `COLORIZE` по умолчанию будет `true` для `console`, как
описано, в противном случае - `false`.

### Ненаследуемые значения по умолчанию

Есть несколько значений, которые не наследуются, как описано выше, а
используются по умолчанию для тех, которые относятся к типу логгера, это:
`EXPRESSION`, `FLAGS`, `PREFIX` и `FILE_NAME`.

#### `EXPRESSION`

`EXPRESSION` представляет собой регулярное выражение, которому должны соответствовать события журнала, чтобы их регистрировал подлоггер. Либо сообщение журнала (с удаленными цветами) должно совпадать, либо должно совпадать `longfilename:lnumber:functionname`. NB: полное сообщение или строка не обязательно должны совпадать.

Обратите внимание, что это выражение будет выполняться в горутине сублоггера,
а не в подпрограмме регистрации событий. Поэтому это может быть сложно.

#### `FLAGS`

`FLAGS` представляет предшествующую контекстную информацию ведения журнала,
которая печатается перед каждым сообщением. Это набор строк, разделенных запятыми. Порядок значений не имеет значения.

Возможные значения:

* `none` или `,` - Без флагов.
* `date` - дата в местном часовом поясе: `2009/01/23`.
* `time` - время в местном часовом поясе: `01:23:23`.
* `microseconds` - микросекундное разрешение: `01:23:23.123123`. Предполагает
время.
* `longfile` - полное имя файла и номер строки: `/a/b/c/d.go:23`.
* `shortfile` - конечный элемент имени файла и номер строки: `d.go:23`.
* `funcname` - имя функции вызывающего: `runtime.Caller()`.
* `shortfuncname` - последняя часть имени функции. Отменяет
`funcname`.
* `utc` - если дата или время установлены, используйте UTC, а не местный часовой
пояс.
* `levelinitial` - Начальный символ предоставленного уровня в скобках, например. `[I]` для информации.
* `level` - Указанный уровень в скобках `[INFO]`
* `medfile` - Последние 20 символов имени файла - эквивалентно
`shortfile,longfile`.
* `stdflags` - Эквивалентно `date,time,medfile,shortfuncname,levelinitial`

### Консольный режим

Для регистраторов в консольном режиме для параметра `COLORIZE` по умолчанию
будет установлено значение `true`, если не в Windows, или терминал Windows
может быть установлен в режим ANSI или является каналом cygwin или Msys.

Если для параметра `STDERR` установлено значение `true`, регистратор будет использовать `os.Stderr` вместо
`os.Stdout`.

### Файловый режим

Значения по умолчанию для `FILE_NAME` указаны выше. Если установлено, он
 будет относиться к предоставленному `ROOT_PATH` в главном разделе `[log]`.

Прочие значения:

* `LOG_ROTATE`: **true**: Поверните файлы журнала.
* `MAX_SIZE_SHIFT`: **28**: Максимальный сдвиг размера одного файла, 28 представляет 256 МБ.
* `DAILY_ROTATE`: **true**: Ежедневно меняйте журналы.
* `MAX_DAYS`: **7**: Удалить файл журнала через x дней
* `COMPRESS`: **true**: Сжимайте старые файлы журналов по умолчанию с помощью gzip
* `COMPRESSION_LEVEL`: **-1**: Уровень сжатия

### Режим подключения

* `RECONNECT_ON_MSG`: **false**: Повторно подключайте хост для каждого сообщения.
* `RECONNECT`: **false**: Попытайтесь восстановить соединение, когда соединение потеряно.
* `PROTOCOL`: **tcp**: Установите протокол: "tcp", "unix" или "udp".
* `ADDR`: **:7020**: Устанавливает адрес для подключения.

### SMTP режим

Не рекомендуется использовать этот логгер для отправки общих
сообщений журнала. Однако, возможно, вы могли бы настроить этот логгер для работы на `FATAL`.

* `USER`: Адрес электронной почты пользователя для отправки.
* `PASSWD`: Пароль для smtp сервера.
* `HOST`: **127.0.0.1:25**: Хост SMTP, к которому нужно подключиться.
* `RECEIVERS`: Адреса электронной почты для отправки.
* `SUBJECT`: **Диагностическое сообщение от Gitea**

## Конфигурация по умолчанию

Пустая конфигурация по умолчанию эквивалентна:

```ini
[log]
ROOT_PATH = %(GITEA_WORK_DIR)/log
MODE = console
LEVEL = Info
STACKTRACE_LEVEL = None
REDIRECT_MACARON_LOG = false
ENABLE_ACCESS_LOG = false
ENABLE_XORM_LOG = true
XORM = ,

[log.console]
MODE = console
LEVEL = %(LEVEL)
STACKTRACE_LEVEL = %(STACKTRACE_LEVEL)
FLAGS = stdflags
PREFIX =
COLORIZE = true # Or false if your windows terminal cannot color
```

Это эквивалентно отправке всех журналов на консоль, при этом журнал go по умолчанию также отправляется в журнал консоли.

## Освобождение и повторное открытие, приостановка и возобновление ведения журнала

Если вы работаете в Unix, вы можете захотеть выпустить и повторно открыть журналы, чтобы использовать logrotate
или другие инструменты. Можно заставить gitea освободить и повторно открыть файлы журналов и подключения, отправив
SIGUSR1 запущенному процессу или запустив gitea manager logging release-and-reopen.

В качестве альтернативы вы можете захотеть приостановить и возобновить ведение журнала - это можно сделать
с помощью команд `gitea manager logging pause` и `gitea manager logging resume`. Обратите внимание, что пока
ведение журнала приостановлено, события журнала ниже уровня ИНФОРМАЦИИ не будут сохраняться, и будет
сохраняться только ограниченное количество событий. Ведение журнала может блокировать, хотя и временно,
значительно замедляя gitea во время паузы - поэтому рекомендуется делать паузу только на очень короткий период времени.

## Добавление и удаление журналов во время работы Gitea

Можно добавлять и удалять ведение журнала во время работы Gitea с помощью подкоманд `gitea manager logging add` и `remove`. Эта функция
может только настроить работающие системы журналов и не может использоваться для запуска регистраторов доступа, Macaron или
маршрутизатора, если они еще не были инициализированы. Если вы хотите запустить эти системы, вам рекомендуется настроить app.ini и
(аккуратно) перезапустить службу Gitea.

Основная цель этих команд - легко добавить временный регистратор для исследования проблем в работающих системах, где перезагрузка
может привести к исчезновению проблемы.

## Раскрашивание журнала

Журналы консоли будут раскрашены по умолчанию, если они не запущены
в Windows. Обнюхивание терминала будет происходить в Windows, и если
будет установлено, что мы работаем на терминале, поддерживающем цвет,
мы раскрасим его.

Кроме того, в *nix файлы журналов по умолчанию окрашены в цвет.
Поэтому журналы файлов по умолчанию будут раскрашены, если они
не запущены в Windows.

Вы можете включить или выключить раскрашивание, используя значение `COLORIZE`.

С точки зрения развития. Если вы напишете `log.Info("A %s string","formatted")`
часть сообщения `formatted` журнала будет выделена жирным шрифтом на раскрашенных журналах.

Вы можете изменить это, отрисовав отформатированную строку самостоятельно.
Или вы можете заключить значение в структуру `log.ColoredValue`.

Структура `log.ColoredValue` содержит указатель на значение, указатель 
на строку байтов, которая должна представлять цвет, и второй набор байтов
сброса. Указатели были выбраны для предотвращения копирования большого
количества значений. Есть несколько вспомогательных методов:

* `log.NewColoredValue` принимает значение и 0 или более атрибутов цвета,
представляющих цвет. Если задано 0, по умолчанию будет выделен полужирный шрифт в кэше.
Обратите внимание: рекомендуется кэшировать байты цвета, созданные из атрибутов, если
это обычно используемое сообщение журнала.
* `log.NewColoredValuePointer` принимает указатель на значение и
0 или более атрибутов цвета, представляющих цвет.
* `log.NewColoredValueBytes` принимает значение и указатель на массив
байтов, представляющих цвет.

Эти функции не будут дублировать `log.ColoredValue`. Они также
установят `resetBytes` в кэшированный `resetBytes`.

`ColorBytes` и `resetBytes` не экспортируются, чтобы предотвратить
случайную перезапись внутренних значений.

## ColorFormat и ColorFormatted

Структуры могут реализовывать интерфейс `log.ColorFormatted` путем реализации функции `ColorFormat(fmt.State)`.

Если структура `log.ColorFormatted` регистрируется в формате `%-v`, её `ColorFormat` будет использоваться вместо обычного `%v`. Будет передан полный `fmt.State`, чтобы разработчики могли посмотреть на дополнительные флаги.

Чтобы помочь разработчикам предоставить методы `ColorFormat`. В модуле журнала
есть функция `log.ColorFprintf(...)`, которая помещает значения в `log.ColoredValue` и распознаёт`%-v`.

В общем, не рекомендуется делать результаты этой функции слишком подробными, чтобы повысить её универсальность. Обычно это должен быть просто `ID`:`Name`. Если вы хотите получить более подробный результат, рекомендуется использовать `%-+v` в качестве маркера.

## Защита от спуфинга журнала

Чтобы защитить журналы от подделки грамотно построенными
сообщениями. Новые строки теперь имеют префикс табуляции,
а управляющие символы, за исключением тех, которые используются
в ANSI CSI, экранируются предшествующим символом `\` и их восьмеричным значением.

## Создание новой именованной группы логгеров

Если разработчик захочет создать новый именованный регистратор, `NEWONE`.
Рекомендуется добавить значение `ENABLE_NEWONE_LOG` в раздел` [log]` 
и добавить новое значение `NEWONE` для режимов.

Для управления построением именованного регистратора рекомендуется использовать
функцию типа `func newNewOneLogService()`. например

```go
func newNewoneLogService() {
	EnableNewoneLog = Cfg.Section("log").Key("ENABLE_NEWONE_LOG").MustBool(false)
	Cfg.Section("log").Key("NEWONE").MustString("file") // or console? or "," if you want to send this to default logger by default
	if EnableNewoneLog {
		options := newDefaultLogOptions()
		options.filename = filepath.Join(LogRootPath, "newone.log")
		options.flags = "stdflags"
		options.bufferLength = Cfg.Section("log").Key("BUFFER_LEN").MustInt64(10000)
		generateNamedLogger("newone", options)
	}
}
```

Затем вам следует добавить `newOneLogService` для `NewServices()` в
`modules/setting/setting.go`

## Использование `logrotate` вместо встроенной ротации журналов

Gitea включает встроенную ротацию журналов, которой должно хватить для большинства развёртываний. Однако, если вы вместо этого хотите использовать утилиту `logrotate`:

-  Отключите встроенную ротацию журналов, установив `LOG_ROTATE` на `false` в вашем `app.ini`.
-  Установите `logrotate`.
-  Настройте `logrotate` Чтобы соответствовать вашим требованиям к развёртыванию, см. `man 8 logrotate` для деталей синтаксиса конфигурации. В блоке `postrotate/endcript` отправьте Gitea сигнал `USR1` через `kill-USR1` или `kill-10` или запустите `gitea manager logging release-and-reopen` (с соответствующей средой). Убедитесь, что ваши настройки применяются ко всем файлам, создаваемым регистраторами Gitea, как описано в разделах выше.
-  Всегда делайте `logrotate /etc/logrotate.conf --debug` для проверки вашей конфигураций.

Следующие задания `logrotate` будут включать ваши конфигурации, поэтому перезапуск не требуется. Вы также можете сразу перезагрузить `logrotate` с помощью `logrotate /etc/logrotate.conf --force`.
